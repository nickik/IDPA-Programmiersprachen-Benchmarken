\documentclass{fancydocument}

\usepackage{enumerate}

\title{IDPA: Programmiersprachen benchmarken}
\author{Nick Zbinden und Matthias Gasser}
\date{\today}
\begin{document}
\maketitle
\thispagestyle{fancy}

\section{Vorwort}
%Dieses Projrkt ist aus dem Willen heraus entstanden eine Arbeit zu
%machen die Applikations. und Systemtechnikenkenntniss nuetzt und
%verbindet. Nach verschiedenen Ideen einigten wir uns ...
Die Informatik hat auf uns schon immer eine gewisse Faszination ausgeübt. Es war daher für uns beide naheliegend eine Lehre als Informatiker zu machen. Während Nick vor allem an der Softwareentwicklung interessiert ist, bevorzuge ich die Systemtechnik, in der die Installation und Wartung von IT-Systemen der Grosse Schwerpunkt ist.
Da wir beide unsere Berufe noch immer sehr interessiert ausführen, war es für uns beide klar für die IDPA ein Thema aus dem Bereich Informatik zu wählen. Es galt nun ein Thema zu finden, in dem sowohl die Applikationsentwicklung wie auch die Systemtechnik gleichermassen eine Rolle spielen. Bereits nach kurzer Recherche stiessen wir auf das Thema „Programmiersprachen Benchmarking“. Sofort war unser beider Interesse geweckt und dadurch,  dass dieses Thema sowohl ein Testsystem wie auch selbstgeschriebene Programme erforderte, eignete es sich sehr gut für eine IDPA. Wir entschieden uns, unsere Maturaarbeit diesem Thema zu widmen.
Am gewählten Thema interessiert uns beide in erster Linie ob tatsächlich Performanceunterschiede zwischen den untersuchten Sprachen feststellbar sind, und in welchem Ausmass sie sich zeigen. Heutige Computer sind sehr leistungsfähig, dadurch ist es für kleinere Programme wie wir sie testen werden meist irrelevant ob eine Programmiersprache einige Millisekunden schneller ist als die andere. Für grössere Projekte spielt die Geschwindigkeit jedoch auch heute noch eine wichtige Rolle, wir hoffen daher, dass sich unsere Testergebnisse auf grössere Applikationen projizieren lassen.

\section{Abstract}
Wir haben uns entschieden für unsere Maturaarbeit die Programmiersprachen Java, Clojure und Scala zu vergleichen. Wir haben dazu ein identisches Programm in jeder der genannten Programmiersprachen geschrieben. Durch das Messen von Prozessor- und Speicherdaten sowie der Ausführungszeiten der Programme wollten wir Unterschiede feststellen, um am Ende aufzeigen zu können, welche der getesteten Sprachen vom Testsystem am wenigsten Leistung abverlangt. Für die Messungen haben wir ein Script geschrieben, welches die erforderlichen Daten in angemessenen Zeitabständen ausliest. 

\section{Einleitung}

\subsection{Untersuchungsgegenstand}
Wir haben uns ein sehr kompliertes Thema
vorgenommen. Programmiersprachen und Compiler sind, zumindes f\"ur die
Informatik, einen sehr altes Thema. \\

Hochsprachen wie wir Sie in dieser Arbeit verwenden werden seit mehr
als f\"unfzig Jahren immer wieder weiter entwickelt und verbessert. Seit
der Anfangszeit herscht der Konflikt zwischen hoher Abstraktion und
Geschwindikeit. Umso h\"oher die Abstraktion ist die eine
Programmiersprache bietet umso schwieriger ist die Programmiersprache
auf der darunterliegenden effizient auszuf\"uhren. 

\subsection{Problemstellung}

Wir haben uns die Aufgabe gestellt drei Programmiersprachen unter dem
asbekt der Geschwindigkeit anzuschauen und zu vergleichen. Eine
definitives Ergebniss ist in diesem Bereich fast unm\"oglich da die
Anwendungsgebiete einer Programmiersprache zu verschieden sind und
jeder Anwendungsfall andere Requirements hat. Auch die
unter der Programmiersprache liegenden Layers (Betriebssysteme und
Hardware) sind von entscheidender Bedeutung. Um korrekte Aussagen zu
machen m\"ussen diese Layers entweder herausgerechnet werden oder
identisch sein. Das Ziel ist es f�r unseren Anwendungsfall Messungen
zu machen, Aussagen �ber die geschwindikeiten zu treffen und
wenn m�glich kl�hren warum die Sprachen in diesem Beispiel so schnell
sind wie sie sind.

\subsection{Wissensl�cken}

Um komplizierte Algorithmen in drei verschiedenen Sprachen zu
programmieren braucht man viel Erfahrung in diesen Sprachen. Um den
Aufwand nicht zu hoch werden zu lassen haben wir uns auf die
Implementierung in einer Programmiersprache spezialisiert und
vergleichen diese mit reference Implementationen die wir nur Erkl\"ahren
und messen.

\section{Material und Methoden}
\subsection{Allgemeines zu den Versuchen}
\subsection{Verwendete Programmiersprachen}
\subsection{Das Testsystem}
\subsection{Aufnahme der Daten}
\subsection{Datenauswertungsmethoden}
\section{Ergebnisse}

\subsection{Allgemeines zu den Sprachen}

Um es einfacher und fair und simple  zu machen haben wir uns Entschieden
Programmiersprachen zu nehmen die auf der JVM (oder anderen VMs die
Java Byte Code ausf�hren) laufen. Das modell der VM bietet
verschiedene Vorteile die ich kurz erl�utern m�chte.
\\
Da VM einen Bytecode als Input erhalten ist es grunds�tzlich m�glich
jeder Programmiersprache auf einer VM laufen zu lassen. Wie dieser
Bytecode in der VM ausgef�hrt wird ist den dar�ber liegenden Sprachen
egal.\\ 
Einige M�glichkeiten wie eine VM den Bytecode ausf�hen:

\begin{itemize}
\item Interpreter
\item JIT-Compiler
\item Native Code Compiler
\item Direkt auf Hardware
\end{itemize}

Ich m�chte nur auf den JIT-Compiler etwas n�her eingehen da die JVM
die wir ben�tzen einen solchen verwendet (Hotspot). Um zu verstehen warum ein
Programm langsam oder schnell ist muss man bis zu einem gewissen grad
den Compiler verstehen.

\subsubsection{JIT Compiler}

Ein JIT-Compiler compiliert nicht alles auf einmal sonder, nur den
Code den auch wirklich braucht. Das erlaubt es dem Compiler
obtimierungen an den wichtigen Stellen anzubringen. Ein weiterer
grosser Vorteil ist es, dass dem JIT-Compiler die Umgebung auf der er
sich befindet bekannt ist. Das erlaubt es obtimierungen anzubringen
die speziell f�r diese Hardware den Code anpassen.
\\
Gute JIT-Compiler sind heutzutage vergleichbar mit der Geschwindikeiten
von Native Code Compilern. Die Unterschiede sind in vielen
Anwendungsf�llen nur noch gering. 

 

\subsection{Java}

\subsubsection{Beschreibung}

Java ist eine Programmiersprache die von 1992 an von Sun Microsystems (oder
teilweise im Auftrag von Sun) entwickelt wurde. Java wurde zuerst f�r
Embedet Systems geschrieben. Heutzutage findet man Java Applikation in
vielen Anwendungsgebieten.

Java ist eine der meist verwendeten Programmiersprachen und wird auch
in vielen Unversit�ten gelehre. 
%Siehe Tiobe index ...


\subsection{Scala}

\subsubsection{Beschreibung}

Die Entwicklung von Scala hat 2001 an der ETH Lausanne unter Martin
Odersky begonnen. Die Idee ist es eine Sprache zu designen die
Konzepte eine Funktionalen und Objektorientiertersprachen in syntese
verwendet. Zwar wurde Scala im Akademischen Kontext entwickelt findet
aber immer mehr Anwendungen im Bussness Bereichen


\subsection{Clojure}

\subsubsection{Beschreibung}

Clojure ist eine dynamische Programmiersprache die 2007 von Rich Hicky
f�r die JVM geschrieben wurde. Im Vordergrund der Entwicklung standen
hohe Abstraktion, vor allem bei Concurency Programming, und gut
integration ins Host System (JVM). Diese erlaubt Wiederverwednung von
Java Code, Java Ecosystems (Webservers, Profilers, Debuggers
...) und nat�rlich der VM.



\section{Diskussiona}
\subsection{Vergleich der Resultate}
\subsection{Schlussfolgerung}
\section{Abk\"urzungsverzeichnis}

VM  - Virtuall Maschine
JVM - Java Virtuell Maschine
IL - Interniediet Language

\section{Literaturverzeichnis}



\section{Glossar}

Virtuall Maschine: Eine Virtuall Maschine ist eine Programm welches simuliert eine echte
Maschine zu sein. Sie bekommt als input irgend eine Sprache und fuert
diese auf der darunter liegenden Sprache aus.

Java Virtuall Maschiene: Eine implementation einer VM die dafuer ausgelegt ist Java Bytecode auszufueren.

Bytecode: Ein Instruktionsset f�r eine VM.
Java Bytecode: Java Bytecode ist der f�r Java bzw. f�r die JVM
entwickelte Bytecode.


\section{Anhang}


\end{document}
