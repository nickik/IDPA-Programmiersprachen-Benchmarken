\documentclass{fancydocument}

\usepackage{enumerate}
\usepackage{listings}
\usepackage{courier}
\usepackage{tabularx}
\usepackage{array}

\title{Programmiersprachen benchmarken}
\title{Programmiersprachen benchmarken - \\ \renewcommand{\baselinestretch}{1.50}\large Programmiersprache ist nicht gleich Programmiersprache}
\author{Nick Zbinden und Matthias Gasser}
\date{\today}
\begin{document}
\maketitle
\thispagestyle{fancy}
\vspace*{\fill}
\noindent
Berufsbildungszentrum Bau und Gewerbe, Luzern\\
Klasse: BML08E
\newpage
\tableofcontents
\definecolor{lineno}{rgb}{0.5,0.5,0.5}
\definecolor{code}{rgb}{0,0.1,0.6}
\definecolor{keyword}{rgb}{0.5,0.1,0.1}
\definecolor{titlebox}{rgb}{0.85,0.85,0.85}
\definecolor{download}{rgb}{0.8,0.1,0.5}
\definecolor{title}{rgb}{0.4,0.4,0.4}

\lstdefinelanguage{clojure}
{
    morekeywords={*agent*, *clojure-version*, *command-line-args*, *compile-files*, *compile-path*, *e, *err*, *file*, *flush-on-newline*, *in*, *ns*, *out*, *print-dup*, *print-length*, *print-level*, *print-meta*, *print-readably*, *read-eval*, *warn-on-reflection*, +, -, ->, ->>, .., /, <, <=, =, ==, >, >=, accessor, aclone, add-classpath, add-watch, agent, agent-error, agent-errors, aget, alength, alias, all-ns, alter, alter-meta!, alter-var-root, amap, ancestors, and, apply, areduce, array-map, aset, aset-boolean, aset-byte, aset-char, aset-double, aset-float, aset-int, aset-long, aset-short, assert, assoc, assoc!, assoc-in, associative?, atom, await, await-for, bases, bean, bigdec, bigint, binding, bit-and, bit-and-not, bit-clear, bit-flip, bit-not, bit-or, bit-set, bit-shift-left, bit-shift-right, bit-test, bit-xor, boolean, boolean-array, booleans, bound-fn, bound-fn*, bound?, butlast, byte, byte-array, bytes, case, cast, char, char-array, char-escape-string, char-name-string, char?, chars, class, class?, clear-agent-errors, clojure-version, coll?, comment, commute, comp, comparator, compare, compare-and-set!, compile, complement, concat, cond, condp, conj, conj!, cons, constantly, construct-proxy, contains?, count, counted?, create-ns, create-struct, cycle, dec, decimal?, declare, definline, defmacro, defmethod, defmulti, defn, defn-,def, defonce, defprotocol, defrecord, defstruct, deftype, delay, delay?, deliver, denominator, deref, derive, descendants, disj, disj!, dissoc, dissoc!, distinct, distinct?, doall, doc, dorun, doseq, dosync, dotimes, doto, double, double-array, doubles, drop, drop-last, drop-while, empty, empty?, ensure, enumeration-seq, error-handler, error-mode, eval, even?, every?, extend, extend-protocol, extend-type, extenders, extends?, false?, ffirst, file-seq, filter, find, find-doc, find-ns, find-var, first, flatten, float, float-array, float?, floats, flush, fn, fn?, fnext, fnil, for, force, format, frequencies, future, future-call, future-cancel, future-cancelled?, future-done?, future?, gen-class, gen-interface, gensym, get, get-in, get-method, get-proxy-class, get-thread-bindings, get-validator, group-by, hash, hash-map, hash-set, identical?, identity, if-let, if-not, ifn?, import, in-ns, inc, init-proxy, instance?, int, int-array, integer?, interleave, intern, interpose, into, into-array, ints, io!, isa?, iterate, iterator-seq, juxt, keep, keep-indexed, key, keys, keyword, keyword?, last, lazy-cat, lazy-seq, let, letfn, line-seq, list, list*, list?, load, load-file, load-reader, load-string, loaded-libs, locking, long, long-array, longs, loop, macroexpand, macroexpand-1, make-array, make-hierarchy, map, map-indexed, map?, mapcat, max, max-key, memfn, memoize, merge, merge-with, meta, methods, min, min-key, mod, name, namespace, namespace-munge, neg?, newline, next, nfirst, nil?, nnext, not, not-any?, not-empty, not-every?, not=, ns, ns-aliases, ns-imports, ns-interns, ns-map, ns-name, ns-publics, ns-refers, ns-resolve, ns-unalias, ns-unmap, nth, nthnext, num, number?, numerator, object-array, odd?, or, parents, partial, partition, partition-all, partition-by, pcalls, peek, persistent!, pmap, pop, pop!, pop-thread-bindings, pos?, pr, pr-str, prefer-method, prefers, print, print-namespace-doc, print-str, printf, println, println-str, prn, prn-str, promise, proxy, proxy-mappings, proxy-super, push-thread-bindings, pvalues, quot, rand, rand-int, rand-nth, range, ratio?, rationalize, re-find, re-groups, re-matcher, re-matches, re-pattern, re-seq, read, read-line, read-string, reduce, reductions, ref, ref-history-count, ref-max-history, ref-min-history, ref-set, refer, refer-clojure, reify, release-pending-sends, rem, remove, remove-all-methods, remove-method, remove-ns, remove-watch, repeat, repeatedly, replace, replicate, require, reset!, reset-meta!, resolve, rest, restart-agent, resultset-seq, reverse, reversible?, rseq, rsubseq, satisfies?, second, select-keys, send, send-off, seq, seq?, seque, sequence, sequential?, set, set-error-handler!, set-error-mode!, set-validator!, set?, short, short-array, shorts, shuffle, shutdown-agents, slurp, some, sort, sort-by, sorted-map, sorted-map-by, sorted-set, sorted-set-by, sorted?, special-form-anchor, special-symbol?, spit, split-at, split-with, str, string?, struct, struct-map, subs, subseq, subvec, supers, swap!, symbol, symbol?, sync, syntax-symbol-anchor, take, take-last, take-nth, take-while, test, the-ns, thread-bound?, time, to-array, to-array-2d, trampoline, transient, tree-seq, true?, type, unchecked-add, unchecked-dec, unchecked-divide, unchecked-inc, unchecked-multiply, unchecked-negate, unchecked-remainder, unchecked-subtract, underive, update-in, update-proxy, use, val, vals, var-get, var-set, var?, vary-meta, vec, vector, vector-of, vector?, when, when-first, when-let, when-not, while, with-bindings, with-bindings*, with-in-str, with-local-vars, with-meta, with-open, with-out-str, with-precision, xml-seq, zero?, zipmap, recur},
   sensitive,
   alsodigit=-,
   morecomment=[l];,
   morestring=[b]"
  }[keywords,comments,strings]

\lstset{
         language=Clojure,
         basicstyle=\footnotesize\ttfamily, % Standardschrift
         %numbers=left,               % Ort der Zeilennummern
         numberstyle=\tiny,          % Stil der Zeilennummern
         %stepnumber=2,               % Abstand zwischen den Zeilennummern
         numbersep=5pt,              % Abstand der Nummern zum Text
         tabsize=2,                  % Groesse von Tabs
         extendedchars=true,         %
         breaklines=true,            % Zeilen werden Umgebrochen
         keywordstyle=\color{red},         
         stringstyle=\color{black}\ttfamily, % Farbe der String
         showspaces=false,           % Leerzeichen anzeigen ?
         showtabs=false,             % Tabs anzeigen ?
         xleftmargin=17pt,
         framexleftmargin=17pt,
         framexrightmargin=5pt,
         framexbottommargin=4pt,
         showstringspaces=false      % Leerzeichen in Strings anzeigen ?        
}

\newcolumntype{v}[1]{%
  >{\raggedright\hspace{0pt}\arraybackslash}p{#1}%
}

\section{Vorwort}

Die Informatik hat auf uns schon immer eine gewisse Faszination ausgeübt. Es war daher für uns beide naheliegend eine Lehre als Informatiker zu machen. Während Nick vor allem an der Softwareentwicklung interessiert ist, bevorzuge ich die Systemtechnik, in der die Installation und Wartung von IT-Systemen der Grosse Schwerpunkt ist.
Da wir beide unsere Berufe noch immer sehr interessiert ausführen, war es für uns beide klar für die IDPA ein Thema aus dem Bereich Informatik zu wählen. Es galt nun ein Thema zu finden, in dem sowohl die Applikationsentwicklung wie auch die Systemtechnik gleichermassen eine Rolle spielen. Bereits nach kurzer Recherche stiessen wir auf das Thema „Programmiersprachen Benchmarking“. Sofort war unser beider Interesse geweckt und dadurch,  dass dieses Thema sowohl ein Testsystem wie auch selbstgeschriebene Programme erforderte, eignete es sich sehr gut für eine IDPA. Wir entschieden uns, unsere Maturaarbeit diesem Thema zu widmen.

Am gewählten Thema interessiert uns beide in erster Linie ob tatsächlich Performanceunterschiede zwischen den untersuchten Sprachen feststellbar sind, und in welchem Ausmass sie sich zeigen. Heutige Computer sind sehr leistungsfähig, dadurch ist es für kleinere Programme wie wir sie testen werden meist irrelevant ob eine Programmiersprache einige Millisekunden schneller ist als die andere. Für grössere Projekte spielt die Geschwindigkeit jedoch auch heute noch eine wichtige Rolle, wir hoffen daher, dass sich unsere Testergebnisse auf grössere Applikationen projizieren lassen.

\section{Abstract}
Wir haben uns entschieden für unsere Maturaarbeit die Programmiersprachen Java, Clojure und Scala zu vergleichen. Wir haben dazu ein identisches Programm in jeder der genannten Programmiersprachen geschrieben. Durch das Messen von Prozessor- und Speicherdaten sowie der Ausführungszeiten der Programme wollten wir Unterschiede feststellen, um am Ende aufzeigen zu können, welche der getesteten Sprachen vom Testsystem am wenigsten Leistung abverlangt. Für die Messungen haben wir ein Script geschrieben, welches die erforderlichen Daten in angemessenen Zeitabständen ausliest. 

\section{Einleitung}

\subsection{Untersuchungsgegenstand}

Wir haben uns ein sehr komplexes Thema vorgenommen. Programmiersprachen und Compiler sind, auf die Informatik bezogen, einen sehr altes Thema. \\
Hochsprachen wie wir Sie in dieser Arbeit verwenden, werden seit mehr
als fünfzig Jahren immer wieder weiter entwickelt und verbessert. Seit
der Anfangszeit herrscht der Konflikt zwischen hoher Abstraktion und
Geschwindigkeit. Umso höher die Abstraktion ist, die eine
Programmiersprache bietet, umso schwieriger ist die Programmiersprache
auf der darunterliegenden Sprache effizient auszuführen.


\subsection{Problemstellung}

Wir haben uns die Aufgabe gestellt drei Programmiersprachen unter dem
Aspekt der Geschwindigkeit anzuschauen und zu vergleichen. Eine
definitives Ergebnis ist in diesem Bereich fast unmöglich da die
Anwendungsgebiete einer Programmiersprache zu verschieden sind und
jeder Anwendungsfall andere Anforderungen hat. Auch die
unter der Programmiersprache liegenden Layers (Betriebssysteme und
Hardware) sind von entscheidender Bedeutung. Um korrekte Aussagen zu
machen m\"ussen diese Layers entweder herausgerechnet werden oder
identisch sein. Das Ziel ist es f\"ur den von uns ausgew\"ahlten Anwendungsfall Messungen
zu machen, Aussagen \"uber die Geschwindikeiten zu treffen und
wenn m\"oglich kl\"ahren warum die Sprachen so verh\"alt.

\subsection{Wissenslücken}

Um komplizierte Algorithmen in drei verschiedenen Sprachen zu
programmieren braucht man viel Erfahrung in diesen Sprachen. Um den
Aufwand nicht zu hoch werden zu lassen haben wir uns auf die
Implementierung in einer Programmiersprache spezialisiert und
vergleichen diese mit Referenz-Implementationen die wir nur erklären
und messen.

\subsection{Erwartungen}

Wegen er unter der Sprachen liegenden Infrastruktur erwarten wir sehr
\"ahnliche Testresultate. Es ist das erkl\"ahrte Ziel von Clojure und
Scala genau so schnell zu sein wie Java um nie auf Java zur\"uck fallen
zu m\"ussen. 

Wir haben die Hypothese aufgestellt, dass Scala es relativ einfach hat
gleichschneller Code wie Java zu produzieren da die Sprachen beide 
Statische Typeinformation haben, Scala sehr Java \"ahnlich programmiert werden kann
und Scala eine der \"altesten und reifsten JVM-Sprachen ist.

Die Erwartung f\"ur Clojure ist nicht ganz so hoch da das Projekt relativ neu ist. Clojure 
ist ausserdem eine dynamische Programmiersprache diese sind schwerer zu optimieren.

\section{Material und Methoden}

\subsection{Allgemeines}

\subsubsection{Sprachauswahl}

In den letzten Jahren ist ein neuer Trend
erwachsen. Programmiersprachen werden oft nicht mehr von Grund auf neu
aufgebaut sondern versuchen bestehende Infrastrukturen zu verwenden.
\\
Diese bringt Vorteile und Nachteile mit sich. Der Vorteil ist, dass
man sich als Trittbrettfahrer an einer VM anh\"angen kann. In moderne
VM wie der JVM wurden hunderte von Mannjahren investiert und sind
daher sehr stabiel und schon fast \"uberall installiert.

Der zweite Vorteil ist das Interoptabilit\"at zwischen den
verschiedenen Sprachen erreicht werden kann. Somit kann Code
wiederverwendet werden ohne, dass man Zeit in portierung von
Programmen stecken muss die jede Sprach braucht um im echten Leben
verwendung zu finden beispielsweise Datenbank Protokolle, XML Parsers usw.

In der Java Programmiersprach sind all diese Grundlegenden Programme
schon implementiert und die JVM ist eine geeignet Plattform um ander
Sprachen darauf aufzusetzten.

Die entscheidene Frage ist nun warum sollten die Nutzer die neuen
Sprachen ben\"utzen. Die Antwort ist sehr vielf\"alltig. Einige neue
Sprachen (Scala) bieten bessere Typsysteme und dadurch besser
Compiletime Sicherheiten andere Sprachen wie z.B. Groovy versuchen Features
von sehr dynamischen Sprachen zu unterst\"utzen.

Alle diese neuen und spannenden Features sind fantastisch kommen aber
oft auf Kosten der Performance. Das kommt davon das manche Features (Bouncechecking)
einfach per definition Laufzeit brauchen aber oft ist das Problem auch der Unterschied in
den Sprache Semantiken d.h. wenn in einer Sprache ein Feature
unterst\"utzt ist aber in der Host-VM nicht muss um das Problem herum
gearbeitet was zus\"atzlichen Runtime-Overhead verursacht. In dieser
Arbeit haben wir uns zwei der meiste verwendeten neuen JVM-Sprachen
ausgesucht um herauszufinden ob diese es schaffen die Geschwindikeit
der Hostsprache (Java) zu erreichen.

\subsubsection{Zielanpassung: Sprachanpassung}

Im Expose haben wir die drei JVM-Sprachen Clojure, Scala und JRuby
gennant die wir Benchmarken wollten. W\"ahrend der Arbeit haben wir
festgestellt, dass JRuby andere Ziele vorfolgt als maximale
Performance zu bieten und deshalb weder produktiv noch sinnvoll ist
JRuby mit Clojure und Scala, die beide diesen Anspruch haben, zu
vergleichen.

Um JRuby zu ersetzen h\"atten wir eine weiter neue JVM-Sprache
hernehmen k\"onnen (es gibt mehr als einhundert) aber es gibt kaum
Sprachen die weit genug entwickelt sind oder die \"ahnliche Ziele
verfolgen. Deshalb haben wir uns Entschieden den test zu machen ob
Clojure und Scala wirklich die Geschwindigkeit von Java erreichen

\subsubsection{Zielanpassung: Implementierung}

Zuerst war die Idee ein Algorithmus in drei verschiedenen Sprachen zu
implementieren und dann die Performence zu messen. Um einen mehr oder
weniger komplexen Algprithmus in drei Sprachen zu implementieren muss
man diese Sprachen sehr gut kennen und verstehen. Noch schwieriger
wird es wenn Performance noch von grosser wichtigkeit ist. Viele
Sprachen kann man extrem verbiegen was es, auf Kosten von
Einfachheit und Klarheit, erlaubt die Geschwindkeit zu verbessern.

Um solche Progamme zu schreiben sind wir f\"ahig und sich sowas
anzueignen ist of mit Monate langer einarbeitung Verbunden. Deshalb
beschr\"anken wir uns, bei der implementierung, auf eine Sprache. In
den anderen nehmen Reference implementierung und werden diese nur
testen und erkl\"aren.

\subsection{Grundlagen}

\subsubsection{Virtuelle Maschienen}

Um es simpel zu halten haben wir uns Entschieden
Programmiersprachen zu nehmen die auf der JVM (oder anderen VMs die
Java Byte Code ausf\"uhren) laufen. Dies erlaubt uns Aussagen \"uber die
Codegenerierung des Source-to-Bytecoden compilers der Sprache zu
machen.
\\
Da VM einen Bytecode als Input erhalten ist es grunds\"atzlich m\"oglich
jeder Programmiersprache auf einer VM laufen zu lassen. Wie dieser
Bytecode in der VM ausgef\"uhrt wird ist den dar\"uber liegenden Sprachen
egal.\\ 
Einige M\"oglichkeiten wie eine VM den Bytecode ausf\"uhen:

Um es einfacher, fair und simpel zu machen haben wir uns entschieden
Programmiersprachen zu wählen die auf der JVM (oder anderen VMs die
Java Byte Code ausführen) laufen. Das Modell der VM bietet
verschiedene Vorteile die ich kurz erläutern möchte.
\\
Da VMs einen Bytecode als Input erhalten ist es grundsätzlich möglich
jede Programmiersprache auf einer VM laufen zu lassen. Wie dieser
Bytecode in der VM ausgeführt wird ist den darüber liegenden Sprachen
egal.\\ 
Einige Möglichkeiten wie eine VM den Bytecode ausführt:


\begin{itemize}
\item Interpreter
\item JIT-Compiler
\item Native Code Compiler
\item Direkt auf Hardware
\end{itemize}

Ich m\"ochte nur auf den JIT-Compiler etwas n\"aher eingehen da die JVM
die wir ben\"utzen einen solchen verwendet (Hotspot). Um zu verstehen warum ein
Programm langsam oder schnell ist muss man bis zu einem gewissen grad
den Compiler verstehen.

\subsubsection{JIT Compiler}

Ein JIT-Compiler kompiliert nicht alles auf einmal sondern, nur den
Code der auch wirklich gebraucht wird. Das erlaubt es dem Compiler
Optimierungen an den wichtigen Stellen anzubringen. Ein weiterer
grosser Vorteil ist es, dass dem JIT-Compiler die Umgebung auf der er
sich befindet bekannt ist. Das erlaubt es Optimierungen anzubringen
die speziell für diese Hardware den Code anpassen.
\\
Gute JIT-Compiler sind heutzutage vergleichbar mit der Geschwindigkeiten
von Native Code Compilern. Die Unterschiede sind in vielen
Anwendungsf\"allen nur noch gering.

\subsection{Das Testsystem}
\subsubsection{Leistungsdaten}
Beim verwendeten Testsystem  handelt es sich um einen HP Compaq 6710b Notebook mit den folgenden Leistungsdaten.

\begin{itemize}
\item Prozessor: Intel Core 2 Duo T7700 @ 2.4 GHz
\item Arbeitsspeicher: 2 GB
\end{itemize}

Wir haben uns entschieden als Betriebssystem die aktuellste Version der Linux-Distribution Debian zu verwenden. Debian hat die Vorteile, dass es sehr stabil läuft und einfacher zu bedienen ist, als andere Linux-Distributionen. Wir haben uns aus verschiedenen Gründen dafür entschieden unsere Tests Linux-basierend durchzuführen. So ist unter Linux keine Lizenzierung nötig, da das Betriebssystem und der grösste Teil der Programme Open-Source sind  oder  wir haben durch vorgängige Recherchen festgestellt, dass die Auswahl an freien Performance-Monitoring-Tools in der Linux-Welt viel grösser ist.
Die genannten Leistungsdaten sind für die Nachvollziehbarkeit der Messdaten sehr wichtig. Werden die Tests auf einem anderen System wiederholt, kann nicht sichergestellt werden, dass die Resultate identisch sind. 
Des Weiteren ist zu erwähnen, dass obwohl der installierte Prozessor über zwei Cores verfügt, die Testprogramme nur darauf ausgelegt sind, einen zu nutzen. Eine Lastverteilung durch das Betriebssystem findet jedoch trotzdem statt. Die Hauptgründe dafür, dass nur ein Kern genutzt wird, sind die folgenden:

\begin{itemize}
\item Der Programmieraufwand ist kleiner, wenn nur ein Kern genutzt wird
\item Eine Parallelisierung lohnt sich bei zwei Kernen vielfach nicht da der zusätzliche Rechenaufwand grösser ist als der Geschwindigkeitsgewinn.
\end{itemize}

\subsubsection{Swap-Space}
Der Swap-Space ist ein virtueller Speicher welcher vom Betriebssystem genutzt wird, wenn der eingebaute Arbeitsspeicher nicht ausreicht. In der MS Windows-Welt ist der Swap-Space unter der Bezeichnung „Auslagerungsdatei“ bekannt. Der Swap-Space befindet sich auf der Festplatte und ist daher um ca. Faktor 1000 langsamer als der Arbeitsspeicher. Trotzdem ist es wichtig, dass das Betriebssystem notfalls in der Lage ist auf einen Swap zurückgreifen zu können. Ansonsten kann dies zu abstürzen von einzelnen Prozessen oder gar dem ganzen System führen. Da gerade die JVM relativ speicherintensiv ist, wird dies umso wichtiger.

Ein viel diskutiertes Thema wenn es um den Swap-Space geht, ist dessen Grösse. Grundsätzlich wird empfohlen den Swap-Space mindestens gleich gross wie den Arbeitsspeicher, aber höchstens doppelt so gross zu machen. Ich habe mich daher an die Faustregel Swap-Space = 1.5 * Arbeitsspeicher gehalten. Nach oben sind theoretisch übrigens keine Grenzen gesetzt, jedoch ist es fraglich ob ein System jemals einen noch grösseren Swap-Space auslasten wird. Es ist daher reine Speicherverschwendung grössere Bereiche auf der Festplatte für Swap zu reservieren.

\subsection{Aufnahme der Daten}
Nach gründlichen Recherchen und dem Testen diverser Monitoring-Tools kamen wir leider zu Schluss, dass kein Programm unsere Anforderungen ausreichend erfüllen konnte. Das Hauptproblem war meist, dass die Datenaufnahme nicht automatisch gestartet werden konnte. Die Aufzeichnung der Daten manuell zu starten, kam für uns jedoch nicht in Frage, da bereits eine Sekunde Verzögerung zwischen Programmstart und Start der Datenaufnahme den Verlust einer Grossen Datenmenge zur Folge hätte. Des Weiteren boten einige Programme keine oder  nur beschränkte Möglichkeiten um die gesammelten Daten zu speichern.

Als Alternative haben wir uns für ein selbstgeschriebenes Script entschieden. Linux bringt selbst bereits eine Vielzahl an Funktionen mit um Leistungsdaten auszulesen. Bereits nach kurzer Nachforschung zeigte sich, dass eine Automatisierung des Auslesevorgangs mittels Script relativ einfach zu realisieren ist.

\subsubsection{Das Script}
Das folgende Script liest die benötigten Leistungsdaten aus. Ich erkläre die einzelnen Bereiche des Scripts nacheinander um Verwirrung zu vermeiden.

Die erste Zeile informiert Linux darüber, dass es sich um ein Shell-Script handelt, damit das Betriebssystem den Code richtig interpretieren kann. Bei einem Perl Script müsste hier beispielsweise das ‚sh‘ durch ein ‚perl‘ ersetzt werden.

\begin{minipage}{\textwidth}
\begin{lstlisting}[language=bash,caption=Shebang]{}
#!/bin/sh
\end{lstlisting}
\end{minipage}
Die als Parameter mitgegebenen Parameter werden in Variablen gespeichert.

\begin{minipage}{\textwidth}
\begin{lstlisting}[language=bash,caption=Parameter]{}
lang=$1
code=$2
param=$3
\end{lstlisting}
\end{minipage}

Nun folgt die Fehlerbehandlung.  Die erste Zeile besagt, dass wenn im Script ein Fehler auftritt, welcher nicht zuvor durch eine andere Funktion abgefangen wird, die Funktion „error“ ausgeführt werden soll. Dabei ist es egal wodurch der Fehler verursacht wird oder an welcher Stelle er auftritt.

Die Error-Funktion gibt ihrerseits eine Meldung aus, die den Benutzer über das Auftreten des Fehlers aufklärt und evtl. mögliche Ursachen dafür nennt. Anschliessend wird das Script beendet.

\begin{minipage}{\textwidth}
\begin{lstlisting}[language=bash,caption=Fehlerbehandlung,literate=% 
{ü}{{\"u}}1 
{ä}{{\"a}}1 
{ö}{{\"o}}1]{}
trap "error" ERR
#
function error() {
	echo '
##########
Ein unbekannter Fehler ist aufgetreten. Prüfen Sie die folgenden möglichen Fehlerquellen:
- ungültige Java Parameter
- fehlerhafte Programmdatei (*.jar)
##########'
	exit 0
}
\end{lstlisting}
\end{minipage}

Die folgenden beiden Vergleichsoperationen (IF-Konstrukte) dienen ebenfalls der Fehlerbehandlung. Die erste Funktion prüft ob die angegebene Sprache zulässig ist (wenn die Sprache im Parameter \$lang nicht Clojure ist und nicht Java ist und nicht Scala ist, dann führe den folgenden Code aus). Wenn der Vergleich wahr ist, d.h. eine falsche Sprache angegeben wurde, wird eine entsprechende Meldung ausgegeben und das Script beendet.

\begin{minipage}{\textwidth}
\begin{lstlisting}[language=bash,caption=Sprachparameter prüfen]{}
if [ $lang != clojure -a $lang != java -a $lang != scala ] ; then
	echo 'Enter clojure, java or scala for Parameter 1!'
	exit 0
fi
\end{lstlisting}
\end{minipage}

Die zweite Vergleichsoperation überprüft, ob die angegebene auszuführende Programmdatei überhaupt auffindbar ist (wenn die Datei im Parameter \$code nicht vorhanden ist, dann führe den folgenden Code aus). Sollte das Script keine Datei finden können, wird der Benutzer informiert und das Script beendet.

\begin{minipage}{\textwidth}
\begin{lstlisting}[language=bash,caption=Jar-Datei prüfen]{}
if [ ! -f $code ] ; then
	echo 'File "'$code'" not found!'
	exit 0
fi
\end{lstlisting}
\end{minipage}

Der nun folgende Abschnitt überprüft ob bereits Dateien mit Messdaten vorhanden sind. Sollte das der Fall sein fragt das Script beim Benutzer nach, ob die bestehenden Dateien überschrieben werden sollen oder die neuen Messdaten in den bestehenden Dateien, unterhalb der bereits vorhandenen Daten, angehängt werden sollen.

Die for-Schleife wird hier benötigt, weil sich die im Ablageverzeichnis für die Messdaten möglicherweise mehrere Dateien befinden, welche mit dem Parameter \$lang, d.h. der verwendeten Programmiersprache beginnen.  Da die Vergleichsoperation, welche prüft ob entsprechende Dateien vorhanden sind, nur einen Parameter erlaubt, würde das Script in diesem Fall abstürzen. Mit der Schleife wird dem Vergleicher jeweils nur eine einzelne, zu prüfende Datei übergeben.

Falls bereits Dateien vorhanden sind, wird der Benutzer nach dem weiteren Vorgehen gefragt und die Antwort in eine Variable eingelesen. Eine weitere Vergleichsoperation prüft nun ob der Benutzer ein kleines oder grosses Ypsilon (für Yes) eingegeben hat. Ist das der Fall, werden mit dem rm-Befehl die vorhandenen Dateien gelöscht, der Benutzer wird informiert und die Schleife abgebrochen. Hat der Benutzer jedoch etwas anderes oder gar nichts eingegeben, teilt das Script ihm mit, dass es die bestehenden Dateien erneut verwenden wird und bricht ebenfalls die Schleife ab. Es ist hier notwendig die Schleife abzubrechen, da diese die vorhandenen Dateien hochzählt.  Befinden sich also mehrere Dateien im Verzeichnis, würde der Benutzer pro Datei einmal nach dem weiteren Vorgehen abgefragt.

\begin{minipage}{\textwidth}
\begin{lstlisting}[language=bash,caption=Benutzerabfrage,literate=% 
{ü}{{\"u}}1 
{ä}{{\"a}}1 
{ö}{{\"o}}1]{}
for tfile in /opt/data/$lang.* ] ; do
	if [ -f $tfile ] ; then
		echo '
Bestehende Dateien überschreiben? Geben Sie "Y" ein um die bestehenden Datei zu löschen oder drücken Sie Enter um neuen Messdaten in die bestehenden Dateien zu schreiben!'
		read answer
		if [ "$answer" = y -o "$answer" = Y ] ; then
			rm /opt/data/$lang.*
			echo 'Dateien wurden gelöscht!'
			break
		else
			echo 'Daten werden in bestehende Dateien geschrieben!'
			break		
		fi			
	fi
done
\end{lstlisting}
\end{minipage}

In die drei Dateien, in welche die gesammelten Daten gespeichert werden, wird das aktuelle Datum sowie die Uhrzeit geschrieben. Somit ist in den Dateien ersichtlich, von wann genau die Messdaten stammen.

\begin{minipage}{\textwidth}
\begin{lstlisting}[language=bash,caption=Titel einfügen]{}
echo "#
####$(date +%d.%m.%Y" "%T)####
#" | tee -a /opt/data/$lang.memory /opt/data/$lang.cpu /opt/data/$lang.time > /dev/null
\end{lstlisting}
\end{minipage}

In einem ersten Schritt werden die Daten zum Arbeitsspeicher gesammelt. Nachdem der Benutzer informiert wurde, wird dazu das zu überwachende Programm gestartet und gleichzeitig (wird mit dem \&-Zeichen festgelegt) eine Schleife, welche die Daten ausliest. Beim Programmaufruf ist ersichtlich, dass der Parameter \$param mitgegeben wird. Dieser enthält evtl. weitere, notwendige Parameter für die JVM um die Programmausführung zu optimieren. Ohne das \&-Zeichen nach dem Programmaufruf, würden die beiden Befehle nicht gleichzeitig ausgeführt. Somit würden die Daten erst ausgelesen, wenn das Programm bereits durchgelaufen ist. 

Die Schleife prüft als Bedingung ob die Ausgabe von ps \$! Grösser als /dev/null ist. \$! Ist eine Variable, in der die Prozess-ID (PID) des zuletzt gestarteten Programms abgelegt ist. PS ist ein Linux-Befehl um Prozessinformationen anzuzeigen. Bei dem Verzeichnis /dev/null handelt es sich um das bekannte schwarze Loch in Linux. Es steht für das Nichts, die Leere. So lange also die Ausgabe von Prozessinformationen zum zuletzt gestarteten Prozess grösser als nichts ist (d.h. der Prozess ist noch aktiv), wird die Schleife ausgeführt.

Der sed-Befehl kopiert die Zeilen 11 bis 20 aus der Datei /proc/\$!/status in die Datei \$lang.memory. Im Proc-Dateisystem werden die aktuellen System- und Prozessinformationen des Linux-System gespeichert. Auch hier steht \$! wieder für die PID des zuletzt gestarteten Prozesses. Anschliessend wird mit dem echo-Befehl eine Trennzeile in die gleiche Datei geschrieben und das Script wird für die Dauer von 0.2 Sekunden pausiert. An dieser Stelle kann somit festgelegt werden, in welchem Intervall die Daten ausgelesen werden sollen. Da unsere Programme nur eine sehr kurze Ausführungszeit haben, reicht eine Wartezeit von 0.2 Sekunden aus. Ohne Wartezeit wäre die Datenmenge zudem extrem hoch.

\begin{minipage}{\textwidth}
\begin{lstlisting}[language=bash,caption=Speicherdaten sammeln]{}
echo '
Collecting Memory Data...
'
java -server $param -jar $code &
while ps $! > /dev/null
do
	sed -n '11,20p' /proc/$!/status >> /opt/data/$lang.memory
	echo '-----------------------' >> /opt/data/$lang.memory		
	sleep .2
done
echo '
done'
\end{lstlisting}
\end{minipage}

Der zweite Schritt ist das Auslesen der Prozessor-Daten. Dazu wird eine temporäre Datei benötigt. Deren Dateiname wird mit der date-Funktion generiert. Diese schreibt das aktuelle Datum sowie die genaue Uhrzeit in eine Variable. Der Dateiname ist somit einzigartig.

Anschliessend erfolgt der gleiche Programmaufruf wie er bereits für das Auslesen der Speicherdaten benutzt wurde. Die CPU-Daten können leider nicht aus dem proc-Dateisystem ausgelesen werden. Sie werden mit dem ps-Befehl gesammelt und in temporäre Datei geschrieben.

Mit dem ps-Befehl werden jedes Mal zu den Prozessordaten auch die Spaltenüberschriften in die Datei geschrieben. Für eine bessere Darstellung werden diese mit dem sed-Befehl entfernt und die neue Ausgabe in die Datei \$lang.cpu geschrieben. Der sed-Befehl entfernt ab der dritten Zeile jede zweite Zeile in der temporären Datei. Anschliessend wird die temporäre Datei gelöscht.

\begin{minipage}{\textwidth}
\begin{lstlisting}[language=bash,caption=CPU-Daten sammeln]{}
echo '
Collecting CPU Data...
'
random=tmp$(date +%d%m%Y_%H%M%S)
java -server $param -jar $code &	
while ps $! > /dev/null
do
	ps -p $! -o user,pid,%cpu,time >> /opt/data/$random
	sleep .2
done
sed '3~2d' /opt/data/$random >> /opt/data/$lang.cpu
rm /opt/data/\random
echo '
done'
\end{lstlisting}
\end{minipage}

Der letzte Schritt ist nun das Auslesen von Zeitdaten (Wie lange dauert die Programmausführung? Wie viel Zeit davon hat die CPU im Kernel-, wie viel im User-Modus verbracht?). Für diese Daten wird keine Schleife benötigt. Die Daten können mit nur einer Befehlszeile ausgelesen werden. Der Parameter –f definiert das Format der Ausgabe (Was soll ausgegeben und wie sollen die Ausgaben beschriftet werden?), der Parameter –o definiert die Ausgabedatei (Output) und der Parameter –a sorgt dafür, dass die Ausgabedatei nicht überschrieben wird sondern die neuen Daten einfach angehängt (append) werden. Als letzten Parameter erwartet der time-Befehl das Programm welches ausgeführt werden soll.

\begin{minipage}{\textwidth}
\begin{lstlisting}[language=bash,caption=Zeitdaten sammeln]{}
echo '
Collecting Time Data...
'
/usr/bin/time -f "Elapsed real time: %E\nCPU usage: %P\nTotal CPU-seconds in user mode: %U\nTotal CPU-seconds in kernel mode: %S\nName and arguments of the command: %C" -o /opt/data/$lang.time -a java -server $param -jar $code
echo '
done'
\end{lstlisting}
\end{minipage}

\subsection{Datenauswertungsmethoden}

Um die Methoden für die Datenauswertung zu bestimmen ist es vorerst wichtig zu wissen was die gesammelten Daten genau bedeuten um sie später korrekt auswerten zu können. Ich habe in den folgenden drei Unterkapiteln versucht dies möglichst verständlich darzustellen.

\subsubsection{Memory}
Der Memory Bereich ist der wohl komplexeste von allen. Der Begriff des virtuellen Speichers ist hier immer wieder anzutreffen. Deshalb folgt hier eine kurze, vereinfachte Erklärung.
\\\\
\underline{Virtual Memory:} Einem Prozess wird ein Adressbereich simuliert den er alleine für sich benutzen kann. Somit hat der Prozess den Eindruck, über einen zusammenhängenden sTeil des Hauptspeichers zu verfügen. In Wirklichkeit verteilt das Betriebssystem den vom Prozess genutzten Speicher über den ganzen Arbeitsspeicher und teilweise auch den Swap-Space (siehe Bild).
\\\\
In der Folge eine Beispielsausgabe aus unserem Messskript.

\begin{minipage}{\textwidth}
\begin{lstlisting}[language=bash,caption=Speicherdaten]{}
-----------------------
VmPeak:	 1086096 kB
VmSize:	 1036004 kB
VmLck:	       0 kB
VmHWM:	   15304 kB
VmRSS:	   15304 kB
VmData:	  988080 kB
VmStk:	     220 kB
VmExe:	      32 kB
VmLib:	   10960 kB
VmPTE:	     180 kB
-----------------------
\end{lstlisting}
\end{minipage}

\begin{tabular}[c]{|l|p{13cm}|} \hline
\textbf{Wert} & \textbf{Erklärung}\\
\hline
VmPeak & höchster Verbrauch von virtuellem Speicher den der Prozess seit dem Start jemals hatte\\
\hline
VmSize & aktueller Verbrauch von virtuellem Speicher. Darin ist auch VmData eingerechnet wodurch dieser Wert für die Messungen nicht weiter relevant ist (siehe VmData)\\
\hline
VmLck & Bei der virtuellen Speicherverwaltung wird der virtuelle Adressraum in Pages aufgeteilt. Aufgrund eines Fehlers kann es sein, dass eine solche Page gesperrt (locked) wird. Die Grösse des gesperrten Speichers würde, wenn vorhanden, hier angegeben.\\
\hline
VmHWM & HWM = high water mark, höchster Verbrauch von physikalischem Speicher den der Prozess seit dem Start jemals hatte\\
\hline
VmRSS & RSS = resident set size, aktueller Verbrauch von physikalischem Speicher\\
\hline
VmData & Daten auf denen das Programm ausgeführt wird. Sprich die JVM. Dieser Wert enthält auch Daten welche noch nicht in den Arbeitsspeicher geladen wurden weil sie nicht benötigt werden. Da für unsere Messungen nur die Daten im physikalischen Arbeitsspeicher interessant sind, ist dieser Wert für unsere Messungen daher irrelevant.\\
\hline
VmStk & Benötigte Ressourcen für die Ausführung. Dieser Wert ist eingerechnet in VmRSS.\\
\hline
VmExe & Der ausgeführte Programmcode, bzw. die als ausführbar markierten Pages. Dieser Wert ist eingerechnet in VmRSS.\\
\hline
VmLib & Shared Memory, Speicherbereich auf den auch andere Prozesse zugreifen können\\
\hline
VmPTE & Zwischen dem virtuellen und dem physikalischen Speicher befindet sich eine sog. Page Table welche den virtuellen Speicher dem physikalischen zuordnet  (z.B. virt. Adresse 0x01 befindet sich bei 0x0A im Arbeitsspeicher usw.). Die Grösse der Page Table ist in hier angegeben. \\
\hline							
\end{tabular}\vspace{1cm}

\\
Zusammenfassend lässt sich sagen, dass für unsere Messungen lediglich der Wert VmRSS, welcher den tatsächlichen, physikalischen Speicherverbrauch abbildet, relevant ist. Dies weil die anderen Messwerte insofern verfälscht sind, dass sie teilweise gar nie in den Speicher geladen werden (VmPeak, VmSize, VmData) oder weil es für unsere Messungen nicht relevant ist wie gross die einzelnen Datensegmente (VmStk, VmExe) im Speicher sind.

\subsubsection{CPU}
In der Folge eine Beispielausgabe für die  Messung der CPU-Daten mit unserem Script. Neben dem ausführenden Benutzer unter der Prozess-ID sind hier auch die momentane CPU-Auslastung und die vergangene Ausführzeit ersichtlich.

\begin{minipage}{\textwidth}
\begin{lstlisting}[language=bash,caption=Speicherdaten]{}
#
####26.02.2011 13:59:13####
#
USER       PID %CPU     TIME
root      7730  0.0 00:00:00
root      7730  0.0 00:00:00
root      7730 43.0 00:00:00
root      7730 65.0 00:00:00
root      7730 86.0 00:00:00
root      7730  112 00:00:01
root      7730  152 00:00:01
\end{lstlisting}
\end{minipage}

Bei Betrachtung dieser Daten fällt auf den ersten Blick auf, dass die CPU-Auslastung 100\% teilweise übersteigt. Da es sich beim Testsystem um ein Dual-Core System handelt, kann die CPU-Auslastung bis zu 200\% erreichen wenn beide Kerne zu 100\% ausgelastet sind. Aufgrund der heute von beinahe allen Betriebssystemen verwendeten SMP-Systemarchitektur, verwenden die Prozessoren unseres Testsystems einen gemeinsamen Adressraum um Aufgaben dynamisch verteilen zu können. Dies führt jedoch auch zu diesen, auf den ersten Blick verwirrenden, Messdaten. Da die gemessenen Daten aufgrund dessen jedoch keineswegs falsch sind, werden wir diese trotzdem für unsere Benchmarkes verwenden.

Die Spalte TIME gibt auf die Sekunde genau an, wie lange der Prozess bereits aktiv ist. Da wir die aktuellen Daten alle 0.2 Sekunden messen, ergeben sich fünf Zeilen pro Sekunde.

\subsubsection{Time}

Hier eine Beispielausgabe für die Messung der Zeit-Daten mit unserem Script. Erneut tauchen hier evtl. unbekannte Begriffe welche in der Folge kurz erklärt werden.

\begin{minipage}{\textwidth}
\begin{lstlisting}[language=bash,caption=Speicherdaten]{}
#
####26.02.2011 13:59:13####
#
Elapsed real time: 0:02.30
CPU usage: 99%
Total CPU-seconds in user mode: 2.38
Total CPU-seconds in kernel mode: 0.06
Name and arguments of the command: java -server -jar clojure/clojure.jar
\end{lstlisting}
\end{minipage}

\\\\
\noindent
\underline{CPU-Modi:} Man unterscheidet zwischen zwei verschiedenen Betriebsmodi in denen die CPU Prozesse ausführt, es sind dies der Kernel- und der User-Modus.
\\\\
\underline{Kernel Mode:} Der ausgeführte Code hat unbeschränkten Zugang zur Hardware, kann jede Anweisung ausführen und jede Speicheradresse adressieren. Der Kernel Mode ist grundsätzlich für vertrauenswürdige Funktionen des Betriebssystems reserviert. Abstürze in diesem Mode können für das System verheerende Folgen haben.
\\\\
\underline{User Mode:} Der ausgeführte Code hat keine Möglichkeit direkt auf die Hardware zuzugreifen. Sollten solche Zugriffe nötig sein, müssen sie über Schnittstellen des Betriebssystems erfolgen. Durch die Einschränkungen entstehen bei Abstürzen keine Schäden am System.
\\\\
\underline{CPU-seconds:} Zeit in der die CPU tatsächlich mit der Ausführung des Prozesses beschäftigt war. Da durch das Betriebssystem immer auch andere Prozesse aktiv sind, dauert die Programmausführung in der Regel länger als die Anzahl CPU-Seconds die tatsächlich dafür aufgewendet wurden (CPU muss priorisieren). Aufgrund der Multicore Technologie ist es aber durchaus auch möglich, dass für eine Programmausführung mehr CPU-Seconds benötigt werden, als tatsächlich Zeit vergeht da die CPU-Seconds pro Kern gezählt werden.
\\

\begin{tabular}[c]{|p{4cm}|p{11cm}|} \hline
\textbf{Wert} & \textbf{Erklärung}\\
\hline
Elapsed real time & Zeit die für die Programmausführung benötigt wurde\\
\hline
CPU usage & Durchschnittliche CPU-Auslastung während der Programmausführung\\
\hline
Total CPU-seconds in user mode & Im User-Mode verbrachte Zeit\\
\hline
Total CPU-seconds in kernel mode & Im Kernel-Mode verbrachte Zeit\\
\hline
Name and arguments of the command & Ausgeführtes Programm inkl. aller Parameter\\
\hline
\end{tabular}

\subsubsection{Methoden}
Für die Auswertung der Daten gehen wir wie folgt vor.
\begin{itemize}
\item Memory
\begin{itemize}
\item Vergleich des Verlaufes von VmRSS zwischen allen Programmiersprachen
\end{itemize}
\item CPU
\begin{itemize}
\item Vergleich des Verlaufes der CPU-Auslastung aller Programmiersprachen
\item Vergleich der durchschnittlichen CPU-Auslastung während der Ausführung
\end{itemize}
\item Zeit
\begin{itemize}
\item Vergleich der gesamten Ausführungszeit
\item Vergleich der benötigten CPU-seconds (Kernel- und User-Mode)
\end{itemize}
\end{itemize}
Alle Messresultate werden sowohl in tabellarischer wie auch in grafischer Form vorgelegt.
\section{Programmiersprachen und Implementierungen}

\subsection{Java}
\subsubsection{Beschreibung}

Java ist eine Programmiersprache die ab 1992 von Sun Microsystems (oder
teilweise im Auftrag von Sun) entwickelt wurde. Java wurde zuerst f\"r
eingebettete Systeme geschrieben. Heutzutage findet man Java Applikation in
vielen Anwendungsgebieten.
Java ist eine der meist verwendeten Programmiersprachen und wird auch
in vielen Universitäten gelehrt. 
%Siehe Tiobe index ...

\subsection{Scala}

\subsubsection{Beschreibung}

Die Entwicklung von Scala hat 2001 an der ETH Lausanne unter Martin
Odersky begonnen. Die Idee war eine Sprache zu designen, welche die
Konzepte von funktionalen und objektorientierten Sprachen in Synthese
verwendet. Zwar wurde Scala im akademischen Kontext entwickelt findet
aber immer mehr Anwendungen im Business Bereich.

\subsection{Clojure}
\subsubsection{Beschreibung}

Clojure ist eine dynamische Programmiersprache die 2007 von Rich Hicky
für die JVM geschrieben wurde. Im Vordergrund der Entwicklung standen
hohe Abstraktion, vor allem bei Concurency Programming, und eine gute
Integration ins Host System (JVM). Diese erlaubt die Wiederverwendung von
Java Code, Java Ecosystems (Webservers, Profilers, Debuggers...) und natürlich der VM.

\subsubsection{Code}

\section{Ergebnisse}
\section{Diskussion}
\subsection{Vergleich der Resultate}

\subsection{Schlussfolgerung}


\section{Abk\"urzungsverzeichnis}
\begin{tabbing}
\hspace*{2cm}\=\kill
\textbf{CPU} \>Central Processing Unit\\
\textbf{HWM} \>High Water Mark\\
\textbf{IL} \>Intermediate Language\\
\textbf{JVM} \>Java Virtual Machine\\
\textbf{PID} \>Process Identifier\\
\textbf{procfs}\>Process Filesystem
\textbf{PS} \>Process Status\\
\textbf{PTE} \>Page Table Entry\\
\textbf{RAM} \>Random Access Memory\\
\textbf{RSS} \>Resident Set Size\\
\textbf{SED} \>Stream Editor\\
\textbf{SMP} \>Symmetric Multiprocessing\\
\textbf{VM} \>Virtual Machine\\
\end{tabbing}


\section{Glossar}
\renewcommand{\arraystretch}{1.4}
\begin{tabularx}{\linewidth}{p{6.5cm}X}
\textbf{Arbeitsspeicher}&auch Hauptspeicher, dient zum kurzzeitigen Speichern von Daten und ist massiv schneller als Festplatten\\
\textbf{Befehlssatz}&Eine Menge von Befehlen, welche in Maschinensprache vorliegt\\
\textbf{Bytecode}&Ein Befehlssatz für eine VM.\\
\textbf{CPU-Modi}&siehe Kapitel 4.5.3 (Time)\\
\textbf{CPU-second}&siehe Kapitel 4.5.3 (Time)\\
\textbf{Debian}&Eine frei erhältiches Client-Betriebssystem welches auf einem Linux-Kernel basiert\\
\textbf{Hardware}&mechanische und elektronische Teile eines beliebigen Systems, dazu gehören auch Computer\\
\textbf{Java Bytecode}&Der Bytecode für Java bzw. für die JVM\\
\textbf{Java Virtual Machine}&Die Implementierung einer VM, welche darauf ausgelegt ist Java Bytecode auszuführen.\\
\textbf{Kernel Mode}&siehe Kapitel 4.5.3 (Time)\\
\textbf{Kompilierung}&Übersetzung von Quellcode einer Programmiersprache in Maschinensprache\\
\textbf{Maschinensprache}&Befehle, die der Prozessor ohne Kompilierung ausführen kann\\
\textbf{Open-Source}&Software deren Quellcode öffentlich zugänglich ist\\
\textbf{Page}&eine Einheit in die der Arbeitsspeicher unterteilt wird, es handelt sich um die kleinste Speichereinheit, in der Reservationen durchgeführt werden\\
\textbf{Parallelisierung}&Aufteilung eines Programms in mehrere Teile, die gleichzeitig ausgeführt werden können. Das Programm wird dadurch multiprozessorfähig\\
\textbf{Parameter}&ein Wert der einem Programm oder Script mitgegeben wird\\
\end{tabularx}
\newpage
\noindent
\begin{tabularx}{\linewidth}{p{6.5cm}X}
\textbf{Performance-Monitoring-Tool}&Programm, welches die Leistungsdaten eines Computers oder Prozesses überwacht\\
\textbf{Proc}&ein virtuelles Dateisystem welches System- und Prozessinformationen anzeigt\\
\textbf{Script}&ein in einer Scriptsprache geschriebenes Programm\\
\textbf{Scriptsprache}&Programmiersprache welche sich speziell für kleine Programme eignet\\
\textbf{User Mode}&siehe Kapitel 4.5.3 (Time)\\
\textbf{Virtual Machine}&Eine Programm, welches einen physikalischen Computer simuliert. Sie erhält als Input eine beliebige Sprache und führt
diese auf der darunter liegenden Sprache aus.\\
\textbf{Virtual Memory}&siehe Kapitel 4.5.1 (Memory)\\
\end{tabularx}
\section{Literaturverzeichnis}
\noindent
\begin{tabularx}{\linewidth}{@{$\bullet$  }v{15cm}@{}}
Bird, Tim (2009): Runtime Memory Measurement
http://elinux.org/Runtime\_Memory\_Measurement (26.02.2011)\tabularnewline[3pt]
Feiner, Tom (2009): Peak memory usage of a process
http://serverfault.com/questions/11550/peak-memory-usage-of-a-process (26.02.2011)\tabularnewline[3pt]
Fulgham, Brent (2011): The Computer Language Benchmarks Game.
http://shootout.alioth.debian.org/ (26.02.2011)\tabularnewline[3pt]
Gmane.org, Benutzer: shivaligupta (2006): Regarding /proc/<pid>/status
http://article.gmane.org/gmane.linux.kernel.kernelnewbies/15454/match= (26.02.2011)\tabularnewline[3pt]
Kerrisk, Michael (2010): proc - process information pseudo-file system.
http://www.kernel.org/doc/man-pages/online/pages/man5/proc.5.html (26.02.2011)\tabularnewline[3pt]
Mackintosh, David (2010): A definition for a CPU second?
http://serverfault.com/questions/138703/a-definition-for-a-cpu-second (26.02.2011)\tabularnewline[3pt]
McGrath, Roland (2007): Locking Pages
http://www.gnu.org/s/libc/manual/html\_node/Locking-Pages.html#Locking-Pages (26.02.2011)\tabularnewline[3pt]
Santosa, Mulyadi (2006): When Linux Runs Out of Memory.
http://linuxdevcenter.com/pub/a/linux/2006/11/30/linux-out-of-memory.html (26.02.2011)\tabularnewline[3pt]
Turakhia, Bhavin (2010): Understanding and optimizing Memory utilization.
http://careers.directi.com/display/tu/Understanding+and+optimizing+Memory+ utilization (26.02.2011)\tabularnewline[3pt]
University of Alberta (2010): Understanding Memory
http://www.ualberta.ca/CNS/RESEARCH/LinuxClusters/mem.html (26.02.2011)\tabularnewline[3pt]
Unix.com, Benutzer: sysgate (2008): top command + \%CPU usage exceeds 100\%?
http://www.unix.com/unix-dummies-questions-answers/92541-top-command-cpu-usage-exceeds-100-a.html (26.02.2011)\tabularnewline[3pt]
\end{tabularx}
\newpage
\noindent
\begin{tabularx}{\linewidth}{@{$\bullet$  }v{15cm}@{}}
Wikipedia, Benutzer: Guy Harris (2011): Page table
http://en.wikipedia.org/wiki/Page\_table (26.02.2011)\tabularnewline[3pt]
Wikipedia, Benutzer: MetaEntropy (2010): Code segment.
http://en.wikipedia.org/wiki/Code\_segment (26.02.2011)\tabularnewline[3pt]
Wikipedia, Benutzer: Mindmatrix (2011): Stack (data structure)
http://en.wikipedia.org/wiki/Stack\_(data\_structure) (26.02.2011)\tabularnewline[3pt]
Wikipedia, Benutzer: Nat682 (2011): Memory segmentation.
http://en.wikipedia.org/wiki/Segmentation\_(memory) (26.02.2011)\tabularnewline[3pt]
Wikipedia, Benutzer: Rich Farmbrough (2009): Resident set size.
http://en.wikipedia.org/wiki/Resident\_set\_size (26.02.2011)\tabularnewline[3pt]
Wikipedia, unbekannter Autor (2011): Data segment.
http://en.wikipedia.org/wiki/Data\_segment (26.02.2011)\tabularnewline[3pt]
Wikipedia, unbekannter Autor (2011): Virtual memory.
http://en.wikipedia.org/wiki/Virtual\_memory (26.02.2011)\tabularnewline[3pt]
\end{tabularx}

\section{Anhang}





\end{document}
